{
    "collab_server" : "",
    "contents" : "#====================================================\n# Stephanie Thurner\n# University Of Washington\n# email: sthurner@uw.edu\n\n# update of functions 39\n# saves population size of every simulation by year.\n\n#**FIXED** (i hope)\n\n#=====================================================\n\n#set.seed(Sys.time())\n\n#### create omega grid (from Jim)\n## make sure Ngrid here is same as Ngrid in multistep\n## could incorporate this into the multistep function instead ofhaving as input\nCol = colorRampPalette(colors=c(\"blue\",\"grey\",\"red\"))\n#install.packages(\"RandomFields\")\nlibrary(RandomFields)\n\ncreateomegagrid<- function(Ngrid, Nu){\n  SpatialSimModel = \"Matern\"\n  Ngrid = Ngrid\n  Nu = Nu\n  loc_grid = expand.grid( \"x\"=seq(0,1,length=Ngrid), \"y\"=seq(0,1,length=Ngrid) )\n  \n  Col = colorRampPalette(colors=c(\"blue\",\"grey\",\"red\"))\n  X = c(0.183, 0.565, 0.625)\n  Y = c(0.586, 0.182, 0.231)\n  # Seed = Sys.time() ## can i do this?\n  # Seed = Seed + 1\n  # set.seed(Seed)\n  # \n  #png( file=paste(File,\"RandomFields -- explained.png\",sep=\"\"), width=6, height=6, res=200, units=\"in\")\n  #par(mfrow=c(2,1), mar=c(3,3,0.5,0.5), mgp=c(1.5,0.5,0), tck=-0.02, oma=c(2,2,0,0))\n  for(RowI in 1:2){\n    #    if(RowI==1) { Var=0.5; Scale=0.25 }\n    #    if(RowI==2) { Var=1; Scale=0.1 }\n    # set.seed(Seed)\n    if(RowI==1) { Var=2; Scale=0.2 }\n    if(RowI==2) { Var=2; Scale=0.2 }\n    model_O <- RMmatern(nu=Nu, var=Var, scale=Scale)\n    Omega_samp = RFsimulate(model=model_O, x=loc_grid[,'x'], y=loc_grid[,'y'])@data[,1]\n    Omega_grid = matrix(Omega_samp, Ngrid, Ngrid)\n    # image( Omega_grid, col=Col(n=10), xlab=\"Eastings\", ylab=\"Northings\", zlim=c(-3.5,3.5) )\n    Dist = dist( cbind(X,Y) )\n    # points( x=X, y=Y, cex=2, pch=c(\"A\",\"B\",\"C\"))\n    # plot(model_O, ylim=c(0,1.1), xlim=c(0,sqrt(2)), ylab=\"Covariance = f(distance)\", xlab=\"distance\", main=\"\", xaxs=\"i\", yaxs=\"i\", lwd=2, col=\"black\")\n    h = seq(0,3,length=1e5)\n    if(SpatialSimModel==\"Matern\") Cor = 2^(1-Nu) * gamma(Nu)^(-1) * (sqrt(2*Nu)*h/Scale)^Nu * besselK(sqrt(2*Nu) * h/Scale, nu=Nu)\n    Cov = Cor * Var\n    # plot( x=h, y=(Cov), type=\"l\", xlim=c(0,1.4), xaxs=\"i\", yaxs=\"i\", ylim=c(0,1.2) )\n    # abline(v=Dist, col=grey(0.1), lty=\"dotted\")\n    # text(x=Dist, y=0.9-c(0,0.07,0.14), labels=c(\"AB\",\"AC\",\"BC\"))\n    # Caclulate and print range\n    kappa = sqrt(2*Nu)/Scale\n    # print( paste(\"Kappa=\", kappa ))\n    # print( paste(\"Exact range=\", abs(h[which.min( (Cor-0.10)^2 )])))\n    # print( paste(\"Approx. range=\", sqrt(8*Nu) / kappa ))\n    # print( paste(\"Scale=\", Scale ))\n    return(Omega_grid)\n  }\n}\n\n#dev.off()\n\n# Omega_gridSpecies1<- createomegagrid(Ngrid = 10, Nu = .4)  #patchy\n# \n# Omega_gridSpecies2<- createomegagrid(Ngrid = 10, Nu = .001) #relatively random\n\n\n##############################################\n\n# Create start grid\n# Modified Trevor's code - exponentiated grid from jim code first \n\ncreatestartgrid<- function(Jim_grid, Nanimals, Ngrid){\n  N<- exp(Jim_grid)\n  probN<- N/sum(N)\n  # tempm<- matrix(probN, nrow = Ngrid, ncol = Ngrid)\n  # print(tempm)\n  # image(tempm, col=Col(n=10), xlab=\"Eastings\", ylab=\"Northings\", zlim=c(0,.04) )\n  Nexact <- rmultinom(n = 1, size = Nanimals, prob = probN)\n  start_grid<- matrix(Nexact, nrow = Ngrid, ncol = Ngrid )\n  # image(start_grid, col=Col(n=10), x = 0:Ngrid, y= 0:Ngrid, xlab=\"X coordinate - rows\",\n  #       ylab=\"Y coordinate- collumns\",\n  #       zlim=c(1, max(start_grid)))\n  return(start_grid)\n}\n\n# temp2<- createstartgrid(Omega_gridSpecies2, 1000, 10)\n###############################################\n\n##############################################\n# Create habitat quality grid\n# Modified Trevor's code - exponentiated grid from jim code first \n\ncreatehqvec<- function(Jim_grid){\n  N<- exp(Jim_grid)\n  probN<- N/sum(N)\n  \n  return(probN)\n}\n\n# hq1<- createhqvec(Omega_gridSpecies1)\n\n##############################################\n# Redistribute animals\n\nredistributegrid<- function(hqvec, Nanimals, Ngrid){\n  Nexact <- rmultinom(n = 1, size = Nanimals, prob = hqvec)\n  new_grid<- matrix(Nexact, nrow = Ngrid, ncol = Ngrid )\n\n  return(new_grid)\n}\n\n# newgrid1<- redistributegrid(hqvec = hq1, Nanimals = 100, Ngrid = 10)\n\n##############################################\n# no longer complete guess, uses binomial to figure out probability of one success based on \n# prob1success = probability of finding and killing one animal in a square\n# can be adjusted for each species\n\nprobabilityfxn<- function(n,prob1success){\n  prob<- matrix(NA, nrow=nrow(n), ncol=ncol(n))\n  for(i in 1:nrow(n)){\n    for(j in 1:ncol(n)){\n      if(n[i,j] == 0){\n        prob[i,j]<- 0\n      }\n      else{\n        # prob[i,j]<- 1/ (1 + (1/.03- 1)*exp(-.15*n[i,j]))\n        # prob[i,j]<- 1/ (1 + (1/.15- 1)*exp(-.15*n[i,j]))\n        \n        prob[i,j]<- 1 - ( 1 - prob1success)^(n[i,j])\n        \n      }\n    }\n  }\n  return(prob)\n}\n\n#################################################\n\n# Calculate straight distance between two points\n\ndistancefxn<- function(start, target){\n  x1<- start[1]\n  y1<- start[2]\n  x2<- target[1]\n  y2<- target[2]\n  distance<- sqrt((x2 - x1)^2 + (y2-y1)^2)\n  return(distance)\n}\n\n#################################################\n\n# population dynamics\n\npopulationdynamics<- function(original.fxn, current.fxn, Ngrid.fxn, r.fxn, hqvec.fxn){\n  \n  updated<- matrix(NA, nrow = Ngrid.fxn, ncol = Ngrid.fxn) #new distribution\n  \n  currenttotal<- sum(current.fxn) #current population size\n  originaltotal<- sum(original.fxn) #should equal nspecies1 -- carrying capacity\n  \n  ##logistic growth\n  lambda<- currenttotal + r.fxn* currenttotal * (1 - currenttotal/originaltotal)\n  \n  if(originaltotal == 0){\n    print(\"incorrect\")\n    lambda<- 0\n  }\n  \n  ## stochasticity -- poisson process\n  newtotal<-  rpois(1, lambda)\n  \n  ## This combines movement and growth:\n  updated<- redistributegrid(hqvec = hqvec.fxn, Nanimals = newtotal, Ngrid = Ngrid.fxn)\n\n\n  return(updated)\n  \n}\n\n\n################################################\n# Advance one time step\n# Reproduce -> move -> harvest\n# Do not do the population dynamics if step = 1\n\nnexttimestep2species<- function(Ngrid, originalgridsp1, currentgridsp1, rsp1, \n                                originalgridsp2, currentgridsp2, rsp2,\n                                distancegrid, \n                                numberpoachers, \n                                takengridsp1, takengridsp2,\n                                variablec, fixedc, revenuesp1, revenuesp2,\n                                totalrev, totalcost, numbertrips,\n                                prob1successsp1, prob1successsp2, sigmawsp1, sigmawsp2,\n                                sigmav, selectivity = 1, Probleave1,\n                                Probleave2, ammocost, carrybackcost, step, hqvecsp1, hqvecsp2){\n\n  ## population dynamics and movement, new =================\n  # Do not do population dynamics if step = 1, that would be changing the starting grid which we do not want.\n  if(step == 1){\n    updatedgridsp1<- currentgridsp1\n    updatedgridsp2<- currentgridsp2\n  }\n  \n  if(step != 1){\n    updatedgridsp1<- populationdynamics(original.fxn = originalgridsp1, current.fxn =  currentgridsp1, \n                                        Ngrid.fxn =  Ngrid, r.fxn =  rsp1, hqvec.fxn = hqvecsp1)\n    \n    updatedgridsp2<- populationdynamics(original.fxn =  originalgridsp2, current.fxn = currentgridsp2, \n                                        Ngrid.fxn =  Ngrid, r.fxn =  rsp2, hqvec.fxn = hqvecsp2)\n  }\n  \n  ## Cost grid -- not species dependent ==================\n  \n  costgrid<- variablec*distancegrid + fixedc #variable cost per unit of distance traveled\n  #simplified fixed cost to be fixed cost/rhino harvested\n  \n  # add ammo cost and carrying dead animal/animal part cost \n  costgrid<- costgrid + ammocost #+ distancegrid * carrybackcost\n  \n  ############# should i have ammo cost as a probability of harvesting something?\n  \n  profitperyear<- 0\n  \n  catchperyearsp1<- 0\n  \n  catchperyearsp2<- 0\n  \n  totalcatchperyear<- 0\n  \n  sp1rev<- 0\n  \n  sp2rev<- 0\n  \n  expectedprofitperyear<- 0\n  \n  \n  ## POACHING HAPPENS \n  \n  for(num in 1:numberpoachers){\n    \n    c<- 2  #concentration coefficient-- should make function input\n    \n    ## create probability grid-- probability of successful catch for Species 1\n    \n    probabilitygridsp1<- probabilityfxn( n = updatedgridsp1, prob1success = prob1successsp1)\n    \n    ## create probability grid-- probability of successful catch for Species 2\n    \n    probabilitygridsp2<- probabilityfxn(n = updatedgridsp2, prob1success = prob1successsp2)\n    \n    ## Revenue grid -- combines both species? -- this may need to be changed\n    \n    revenuegrid<- revenuesp1 * probabilitygridsp1 + revenuesp2 * probabilitygridsp2 * (1 - probabilitygridsp1) #for species 2, it is the probability you don't catch species 1 AND you catch species two? yeah?\n    \n    profitgrid<- revenuegrid - costgrid   \n    \n    ## ADD OBSERVATION ERROR -- currently have it where the error is different for every grid and for every poacher -- unsure if this should be \"less\" different? Can you correlate observation error? Is that even neccessary?\n\n    observationerror<- matrix(data = rnorm(n = (Ngrid * Ngrid), mean = 0, sd = sigmav), nrow = Ngrid, ncol = Ngrid)\n    \n    profitgrid<- profitgrid + observationerror\n    \n    \n    \n    ## fleet dynamics\n    \n    if(max(profitgrid >=0)){\n      fleetdynamics<- exp(-c * (1 - profitgrid / max(profitgrid)))\n    }\n    else{\n      fleetdynamics<- exp(-c * (1 - profitgrid / .000000001)) \n    }\n    \n    \n    ## Probability for each square\n    \n    if(sum(fleetdynamics) != 0){\n      fleetdynamicsprobability<- fleetdynamics/sum(fleetdynamics)\n    }\n    else{\n      fleetdynamicsprobability<- matrix(0, nrow = Ngrid, ncol = Ngrid)\n    }\n    \n    ## Pick a square to go to\n    \n    randnumb<- runif(n = 1)\n    temp<- 0\n    xtarget<- -1\n    ytarget<- -1\n    cumulativefleetdyprob<- matrix(0, nrow=Ngrid, ncol = Ngrid)\n    marker<- F\n    for(i in 1:Ngrid){\n      for(j in 1:Ngrid){\n        temp<- temp + fleetdynamicsprobability[i,j]\n        cumulativefleetdyprob[i,j]<- temp\n        if(is.na(temp)==TRUE){\n          print(\"WARNING, Temp = NA\")\n          print(temp)\n          print(fleetdynamics)\n          print(fleetdynamicsprobability)\n          print(sum(fleetdynamicsprobability))\n        }\n        else if(randnumb <= temp & marker == F){\n          xtarget<- i\n          ytarget<- j\n          marker<- T\n        }\n      }\n    } \n    \n    \n    ## only harvesting ONE animal!!!!!!!!!!!!!!!\n    \n    if(xtarget != -1){\n      if(marker != F & profitgrid[xtarget, ytarget] > 0){ \n        \n        #keep track of number of trips - the poacher goes\n        numbertrips<- numbertrips + 1\n        \n        # SPECIES 1- catch 1 or 0\n        tempcatchsp1<- rbinom(n = 1, size = 1, prob = probabilitygridsp1[xtarget, ytarget])\n        \n        # SPECIES 2- catch 1 or 0\n        tempcatchsp2<- rbinom(n = 1, size = 1, prob = probabilitygridsp2[xtarget, ytarget])\n        \n        # did they catch anything? \n        \n        # if the revenue is less than the ammunition and cost to carry back, don't harvest\n        \n        addedcost<- ammocost #+ carrybackcost * distancegrid[xtarget, ytarget]\n        \n        if(revenuesp2 <= addedcost){\n          tempcatchsp2<- 0\n        }\n        \n        if(revenuesp1 <= addedcost){\n          tempcatchsp1<- 0\n        }\n        \n        \n        # what happens if they see both? Catch most expensive and not the least expensive\n        if(tempcatchsp1 == 1 & tempcatchsp2 == 1){\n          \n          if(selectivity == 1 ){\n            # print(\"selectivity = always take most profitable\")\n            ## automatically take the most profitable one (even if it is by 50 cents)\n            if(revenuesp1 > revenuesp2){\n              tempcatchsp2<- 0\n            } else if(revenuesp2 > revenuesp1){\n              tempcatchsp1<- 0\n            } else{\n              multinomcatch<- rmultinom(n = 1, size = 1, prob = c(0.5, 0.5))\n              tempcatchsp1<- multinomcatch[1]\n              tempcatchsp2<- multinomcatch[2]\n            }\n          } else {\n            # equal utility per dollar \n            # print(\"selectivity = utility and money have 1:1 ratio\")\n            utilsp1<- revenuesp1/ (revenuesp1 + revenuesp2)\n            utilsp2<- revenuesp2/ (revenuesp1 + revenuesp2)\n            \n            multinomcatch<- rmultinom(n = 1, size = 1, prob = c(utilsp1, utilsp2))\n            tempcatchsp1<- multinomcatch[1]\n            tempcatchsp2 <- multinomcatch[2]\n          }\n          \n        }\n        \n        \n        ## remove catch from Species 1 grid\n        updatedgridsp1[xtarget, ytarget]<- updatedgridsp1[xtarget, ytarget] - tempcatchsp1\n        \n        ## remove catch from Species 2 grid\n        updatedgridsp2[xtarget, ytarget]<- updatedgridsp2[xtarget, ytarget] - tempcatchsp2\n        \n        #keep track of how many Species 1 caught\n        takengridsp1[xtarget, ytarget]<- takengridsp1[xtarget, ytarget] + tempcatchsp1\n        \n        #keep track of how many Species 2 caught\n        takengridsp2[xtarget, ytarget]<- takengridsp2[xtarget, ytarget] + tempcatchsp2\n        \n        #catch per year of species 1\n        catchperyearsp1<- catchperyearsp1 + tempcatchsp1\n        \n        #catch per year of species 2\n        catchperyearsp2<- catchperyearsp2 + tempcatchsp2\n        \n        #total catch per year\n        \n        totalcatchperyear<- totalcatchperyear + tempcatchsp1 + tempcatchsp2\n        \n        #keep track of total revenue, total cost, yearly revenue\n        totalrev<- totalrev + revenuesp1 * tempcatchsp1 + revenuesp2 * tempcatchsp2\n        \n        sp1rev<- sp1rev + revenuesp1 * tempcatchsp1\n        \n        sp2rev<- sp2rev + revenuesp2 * tempcatchsp2\n        \n        totalcost<- totalcost + costgrid[xtarget, ytarget]\n        \n        profitperyear<- profitperyear + revenuesp1 * tempcatchsp1 + revenuesp2 * tempcatchsp2 - costgrid[xtarget, ytarget]\n        \n        expectedprofitperyear<- expectedprofitperyear + profitgrid[xtarget, ytarget] #THIS IS NOT ACCURATE SINCE THEY CAN ONLY CATCH ONE!!!\n        \n      }\n      \n    }\n    \n  }\n\n  \n  new_list <- list(takengridsp1, takengridsp2, updatedgridsp1, updatedgridsp2, totalrev, totalcost, profitperyear, \n                   catchperyearsp1, catchperyearsp2, totalcatchperyear, numbertrips, expectedprofitperyear)\n  return(new_list)\n}\n\n\n\n################################################################\n#advances multiple time steps\n\n\n\nmultipletimesteps2species<- function(Omega_gridsp1.fxn, Omega_gridsp2.fxn, Nanimalssp1.fxn,\n                                     Nanimalssp2.fxn, Ngrid.fxn, \n                                     numberpoachers.fxn, nstep.fxn,\n                                     rsp1.fxn, rsp2.fxn, variablec.fxn, fixedc.fxn, revenuesp1.fxn, revenuesp2.fxn,\n                                     prob1successsp1.fxn, prob1successsp2.fxn, sigmawsp1.fxn, sigmawsp2.fxn,\n                                     sigmav.fxn, selectivity.fxn = 1, Probleave1.fxn,\n                                     Probleave2.fxn, ammocost.fxn, carrybackcost.fxn){\n  \n  marker1<- F\n  marker2<- F\n  \n  extinctionstepsp1<- 0\n  extinctionstepsp2<- 0\n  \n  ####################### arrays to hold distribution grids\n  distarraysp1<- array(data = NA, dim = c(Ngrid.fxn, Ngrid.fxn, (nstep.fxn + 1)))\n  distarraysp2<- array(data = NA, dim = c(Ngrid.fxn, Ngrid.fxn, (nstep.fxn + 1)))\n  #######################\n  \n  ####################### vector to hold population size by year\n  yearlypopsize1<- rep(data = NA, nstep.fxn + 1)\n  yearlypopsize2<- rep(data = NA, nstep.fxn + 1)\n  #######################\n  \n\n  #set.seed(15)\n  \n  originalgridsp1<- createstartgrid(Jim_grid = Omega_gridsp1.fxn, Nanimals = Nanimalssp1.fxn, Ngrid = Ngrid.fxn) #carrying capacity\n  # title(main = \"Original population Species 1\", col.main = \"green\")\n  # print(originalgridsp1)\n  \n  hq1<- createhqvec(Omega_gridsp1.fxn)\n  \n  currentgridsp1<- originalgridsp1  #matrix that will be changed, assume starting at carrying capacity\n  \n  distarraysp1[,,1]<- currentgridsp1\n  \n  yearlypopsize1[1]<- sum(currentgridsp1)\n  \n  \n  ## Starting grid for species 2\n\n  originalgridsp2<- createstartgrid(Jim_grid = Omega_gridsp2.fxn, Nanimals = Nanimalssp2.fxn, Ngrid = Ngrid.fxn) #carrying capacity\n  # title(main = \"Original population Species 2\", col.main = \"green\")\n  # print(originalgridsp2)\n  \n  hq2<- createhqvec(Omega_gridsp2.fxn)\n  \n  currentgridsp2<- originalgridsp2  #matrix that will be changed, assume starting at carrying capacity\n  \n  distarraysp2[,,1]<- currentgridsp2\n  \n  yearlypopsize2[1]<- sum(currentgridsp2)\n  \n  ### distance grid calculation (outside of loop to save time)\n  \n  distancegrid<- matrix(NA, ncol = Ngrid.fxn, nrow= Ngrid.fxn)\n  \n  for(i in 1:Ngrid.fxn){\n    for(j in 1:Ngrid.fxn){\n      distancegrid[i,j]<- distancefxn(start = c(0,0), target = c(i-.5, j-.5))  #note that they are starting in specified corner\n    }\n  }\n  ### \n  #calculate observation error sigma -- based on the total revenue available (may want to make it more specific)\n  \n  sigmav.fxn<- sigmav.fxn * mean(originalgridsp1 * revenuesp1.fxn + originalgridsp2 * revenuesp2.fxn)\n  # \n  #   print(\"mean of revenue grid\")\n  #   print(mean(originalgridsp1 * revenuesp1.fxn + originalgridsp2 * revenuesp2.fxn))\n  \n  # print(\"observation error st.dev\")\n  # print(sigmav.fxn)\n  \n  \n  \n  \n  ###\n  \n  takengridsp1<- matrix(0, nrow = Ngrid.fxn, ncol = Ngrid.fxn) #empty starting grid to fill with captured animals\n  takengridsp2<- matrix(0, nrow = Ngrid.fxn, ncol = Ngrid.fxn) \n  \n  \n  totalrev<- 0 #starting revenue\n  \n  totalcost<- 0 #starting cost\n  \n  numbertrips<- 0 #starting number of trips\n  \n  populationsizesp1<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  populationsizesp2<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  \n  takensp1<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  takensp2<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  \n  totaltaken<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  \n  yearlyprofit<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  \n  yearlytotalcatch<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  yearlycatchsp1<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  yearlycatchsp2<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  \n  expectedyearlyprofit<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)\n  \n  for (step in 1:nstep.fxn){\n    populationsizesp1[step,2]<- sum(currentgridsp1) #starting grid\n    populationsizesp2[step,2]<- sum(currentgridsp2) #starting grid\n    \n    totaltaken[step,2]<- sum(takengridsp1) + sum(takengridsp2)\n    \n    if(sum(currentgridsp1) != 0 | sum(currentgridsp2) != 0){\n      temp<- nexttimestep2species(Ngrid = Ngrid.fxn, originalgridsp1 = originalgridsp1, currentgridsp1 = currentgridsp1,\n                                  rsp1 = rsp1.fxn, originalgridsp2 = originalgridsp2, currentgridsp2 = currentgridsp2, \n                                  rsp2 = rsp2.fxn, \n                                  distancegrid = distancegrid,\n                                  numberpoachers = numberpoachers.fxn, takengridsp1 = takengridsp1, \n                                  takengridsp2 = takengridsp2, \n                                  variablec = variablec.fxn, fixedc = fixedc.fxn, revenuesp1 = revenuesp1.fxn, \n                                  revenuesp2 = revenuesp2.fxn,\n                                  totalrev = totalrev, totalcost = totalcost,\n                                  numbertrips = numbertrips,\n                                  prob1successsp1 = prob1successsp1.fxn, \n                                  prob1successsp2 = prob1successsp2.fxn,\n                                  sigmawsp1 = sigmawsp1.fxn,\n                                  sigmawsp2 = sigmawsp2.fxn,\n                                  sigmav = sigmav.fxn,\n                                  selectivity = selectivity.fxn,\n                                  Probleave1 = Probleave1.fxn,\n                                  Probleave2 = Probleave2.fxn,\n                                  ammocost = ammocost.fxn, \n                                  carrybackcost = carrybackcost.fxn,\n                                  step = step, hqvecsp1 = hq1, hqvecsp2= hq2)\n      \n      currentgridsp1<- temp[[3]] #updates current grid species 1\n      distarraysp1[,,(step + 1)]<- currentgridsp1 #stores grid at end of time step\n      yearlypopsize1[step + 1]<- sum(currentgridsp1) #stores total pop size at end of time step\n      \n      currentgridsp2<- temp[[4]] #updates\n      distarraysp2[,,(step+1)]<- currentgridsp2 #stores grid at end of time step\n      yearlypopsize2[step + 1]<- sum(currentgridsp2) #stores pop size at end of time step\n      \n      takengridsp1<- temp[[1]] #updates taken grid\n      takengridsp2<- temp[[2]]\n      \n      totalrev<- temp[[5]] #updates total revenue\n      totalcost<- temp[[6]] #updates total cost\n      numbertrips<- temp[[11]] #updates number of trips\n      yearlyprofit[step, 2]<- temp[[7]] #keeps track of profit in each time step\n      yearlytotalcatch[step, 2]<- temp[[10]] #keeps track of catch in each time step\n      yearlycatchsp1[step,2]<- temp[[8]]\n      yearlycatchsp2[step,2]<- temp[[9]]\n      expectedyearlyprofit[step, 2]<- temp[[12]]\n      \n      if(sum(currentgridsp1) == 0 & marker1 == F){\n        extinctionstepsp1<- step\n        marker1<- T\n      }\n      \n      if(sum(currentgridsp2) == 0 & marker2 == F){\n        extinctionstepsp2<- step\n        marker2<- T\n      }\n      \n      if(sum(currentgridsp1) == 0 & sum(currentgridsp2) == 0){\n        break\n      }\n    }\n    \n  }\n  \n  # print(\"Total Number Species 1 Taken\")\n  # print(takengridsp1)\n  # print(sum(takengridsp1, na.rm = TRUE)) #total number Species 1 taken\n  # image(takengridsp1, col=Col(n=10), xlab=\"X coordinate - rows\", ylab=\"Y coordinate- collumns\", \n  #       zlim=c(1, max(1,max(takengridsp1))) )\n  # title(main = \"Species 1 number taken\", col.main = \"green\")\n  # #note: not on same color scale as other images\n  # \n  # print(\"Total Number Species 2 Taken\")\n  # print(takengridsp2)\n  # print(sum(takengridsp2, na.rm = TRUE)) #total number Species 1 taken\n  # image(takengridsp2, col=Col(n=10), xlab=\"X coordinate - rows\", ylab=\"Y coordinate- collumns\", \n  #       zlim=c(1, max(1,max(takengridsp2))) )\n  # title(main = \"Species 2 number taken\", col.main = \"green\")\n  # #note: not on same color scale as other images\n  # \n  # \n  # print(\"Animal population Species 1\")\n  # print(currentgridsp1)\n  # print(sum(currentgridsp1))\n  # image(currentgridsp1, col=Col(n=10), xlab=\"X coordinate - rows\", ylab=\"Y coordinate- collumns\",\n  #       zlim=c(1, max(1,max(currentgridsp1))) )\n  # title(main = \"Current population Species 1\", col.main = \"green\")\n  # #note: not on same color scale as other images\n  # \n  # print(\"Animal population Species 2\")\n  # print(currentgridsp2)\n  # print(sum(currentgridsp2))\n  # image(currentgridsp2, col=Col(n=10), xlab=\"X coordinate - rows\", ylab=\"Y coordinate- collumns\",\n  #       zlim=c(1, max(1,max(currentgridsp2))) )\n  # title(main = \"Current population Species 2\", col.main = \"green\")\n  # #note: not on same color scale as other images\n  # \n  # \n  # \n  # print(\"extinction time step Species 1\")\n  # print(extinctionstepsp1)\n  # \n  # print(\"extinction time step Species 2\")\n  # print(extinctionstepsp2)\n  # \n  # print(\"total revenue\")\n  # print(totalrev)\n  # \n  # print(\"total cost\")\n  # print(totalcost)\n  # \n  # print(\"Number of trips\")\n  # print(numbertrips)\n  # \n  # \n  # plot(x = yearlyprofit[,1], y = yearlyprofit[,2], xlab = \"time step\", ylab = \"profit per year\",\n  #      type = \"l\", main = \"profit per time step\")\n  # lines(x = expectedyearlyprofit[,1], y = expectedyearlyprofit[,2], col= \"red\", lty = 3)\n  # \n  # plot(x = populationsizesp1[,1], y = populationsizesp1[,2], xlab = \"time step\", ylab = \"population size\", type = \"l\",\n  #      ylim = c(0, max(Nanimalssp2.fxn, Nanimalssp1.fxn)), main = \"Population size over time\", col = \"orange\")\n  # lines(x = populationsizesp2[,1], y = populationsizesp2[,2], col = \"purple\")\n  # \n  # plot(x = totaltaken[,1], y = totaltaken[,2], xlab = \"time step\", ylab = \"number taken\", type = \"l\",\n  #      main = \"Total number taken over time\")\n  # \n  # \n  # plot(x = yearlytotalcatch[,1], y = yearlytotalcatch[,2], xlab = \"time step\", ylab = \"total number taken per year\", type = \"l\",\n  #      main = \"Total number taken each year\")\n  # lines(x = yearlycatchsp1[,1], y = yearlycatchsp1[,2], col = \"orange\")\n  # lines(x = yearlycatchsp2[,1], y = yearlycatchsp2[,2], col = \"purple\")\n  # \n  \n  invisible(list(originalgridsp1, currentgridsp1, originalgridsp2, currentgridsp2, distarraysp1,\n                 distarraysp2, yearlypopsize1, yearlypopsize2, extinctionstepsp1, extinctionstepsp2))\n}\n\n\n###############################\n# EXAMPLE CODE TO RUN FUNCTION -- plotting is turned off\n# \n# examplecall <- multipletimesteps2species(Omega_gridsp1.fxn = Omega_gridSpecies1, Omega_gridsp2.fxn = Omega_gridSpecies1,\n#                                          Nanimalssp1.fxn = 1000, Nanimalssp2.fxn = 1000, Ngrid.fxn = 10,\n#                                          numberpoachers.fxn = 25, nstep.fxn = 5,\n#                                          rsp1.fxn = .09, rsp2.fxn = .09,\n#                                          variablec.fxn = 100, fixedc.fxn = 100, revenuesp1.fxn = 2000,\n#                                          revenuesp2.fxn = 100,\n#                                          prob1successsp1.fxn = .09, prob1successsp2.fxn = .09,\n#                                          sigmawsp1.fxn = 0, sigmawsp2.fxn = 0, sigmav.fxn = 0,\n#                                          selectivity.fxn = 2, Probleave1.fxn = 0.05, Probleave2.fxn = 0.05,\n#                                          ammocost.fxn = 1, carrybackcost.fxn = 50)\n# examplecall[[1]]\n",
    "created" : 1609286209357.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3488220323",
    "id" : "E6D81E48",
    "lastKnownWriteTime" : 1604421916,
    "last_content_update" : 1609286213527,
    "path" : "C:/Users/Stephanie Thurner/OneDrive - UW/Masters Stuff/Chapter 1 Simulation Runs Redo/Species 2 Growth/Functions - GWDD movement fix_sel1.R",
    "project_path" : "Functions - GWDD movement fix_sel1.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}