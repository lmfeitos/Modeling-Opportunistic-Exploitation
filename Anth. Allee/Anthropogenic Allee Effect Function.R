#====================================================
# Stephanie Thurner
# University Of Washington
# email: sthurner@uw.edu

# changing so that revenue is a function of population size
#=====================================================

#set.seed(Sys.time())

#### create omega grid (from Jim)
## make sure Ngrid here is same as Ngrid in multistep
## could incorporate this into the multistep function instead ofhaving as input
Col = colorRampPalette(colors=c("blue","grey","red"))
#install.packages("RandomFields")
library(RandomFields)

createomegagrid<- function(Ngrid, Nu){
  SpatialSimModel = "Matern"
  Ngrid = Ngrid
  Nu = Nu
  loc_grid = expand.grid( "x"=seq(0,1,length=Ngrid), "y"=seq(0,1,length=Ngrid) )
  
  Col = colorRampPalette(colors=c("blue","grey","red"))
  X = c(0.183, 0.565, 0.625)
  Y = c(0.586, 0.182, 0.231)
  # Seed = Sys.time() ## can i do this?
  # Seed = Seed + 1
  # set.seed(Seed)
  # 
  #png( file=paste(File,"RandomFields -- explained.png",sep=""), width=6, height=6, res=200, units="in")
  #par(mfrow=c(2,1), mar=c(3,3,0.5,0.5), mgp=c(1.5,0.5,0), tck=-0.02, oma=c(2,2,0,0))
  for(RowI in 1:2){
    #    if(RowI==1) { Var=0.5; Scale=0.25 }
    #    if(RowI==2) { Var=1; Scale=0.1 }
    # set.seed(Seed)
    if(RowI==1) { Var=2; Scale=0.2 }
    if(RowI==2) { Var=2; Scale=0.2 }
    model_O <- RMmatern(nu=Nu, var=Var, scale=Scale)
    Omega_samp = RFsimulate(model=model_O, x=loc_grid[,'x'], y=loc_grid[,'y'])@data[,1]
    Omega_grid = matrix(Omega_samp, Ngrid, Ngrid)
    # image( Omega_grid, col=Col(n=10), xlab="Eastings", ylab="Northings", zlim=c(-3.5,3.5) )
    Dist = dist( cbind(X,Y) )
    # points( x=X, y=Y, cex=2, pch=c("A","B","C"))
    # plot(model_O, ylim=c(0,1.1), xlim=c(0,sqrt(2)), ylab="Covariance = f(distance)", xlab="distance", main="", xaxs="i", yaxs="i", lwd=2, col="black")
    h = seq(0,3,length=1e5)
    if(SpatialSimModel=="Matern") Cor = 2^(1-Nu) * gamma(Nu)^(-1) * (sqrt(2*Nu)*h/Scale)^Nu * besselK(sqrt(2*Nu) * h/Scale, nu=Nu)
    Cov = Cor * Var
    # plot( x=h, y=(Cov), type="l", xlim=c(0,1.4), xaxs="i", yaxs="i", ylim=c(0,1.2) )
    # abline(v=Dist, col=grey(0.1), lty="dotted")
    # text(x=Dist, y=0.9-c(0,0.07,0.14), labels=c("AB","AC","BC"))
    # Caclulate and print range
    kappa = sqrt(2*Nu)/Scale
    # print( paste("Kappa=", kappa ))
    # print( paste("Exact range=", abs(h[which.min( (Cor-0.10)^2 )])))
    # print( paste("Approx. range=", sqrt(8*Nu) / kappa ))
    # print( paste("Scale=", Scale ))
    return(Omega_grid)
  }
}

#dev.off()

# Omega_gridSpecies1<- createomegagrid(Ngrid = 10, Nu = .4)  #patchy
# 
# Omega_gridSpecies2<- createomegagrid(Ngrid = 10, Nu = .001) #relatively random


##############################################

# Create start grid
# Modified Trevor's code - exponentiated grid from jim code first 

createstartgrid<- function(Jim_grid, Nanimals, Ngrid){
  N<- exp(Jim_grid)
  probN<- N/sum(N)
  # tempm<- matrix(probN, nrow = Ngrid, ncol = Ngrid)
  # print(tempm)
  # image(tempm, col=Col(n=10), xlab="Eastings", ylab="Northings", zlim=c(0,.04) )
  Nexact <- rmultinom(n = 1, size = Nanimals, prob = probN)
  start_grid<- matrix(Nexact, nrow = Ngrid, ncol = Ngrid )
  # image(start_grid, col=Col(n=10), x = 0:Ngrid, y= 0:Ngrid, xlab="X coordinate - rows",
  #       ylab="Y coordinate- collumns",
  #       zlim=c(1, max(start_grid)))
  return(start_grid)
}

# temp2<- createstartgrid(Omega_gridSpecies2, 1000, 10)
###############################################

##############################################
# Create habitat quality grid
# Modified Trevor's code - exponentiated grid from jim code first 

createhqvec<- function(Jim_grid){
  N<- exp(Jim_grid)
  probN<- N/sum(N)
  
  return(probN)
}

# hq1<- createhqvec(Omega_gridSpecies1)

##############################################
# Redistribute animals

redistributegrid<- function(hqvec, Nanimals, Ngrid){
  Nexact <- rmultinom(n = 1, size = Nanimals, prob = hqvec)
  new_grid<- matrix(Nexact, nrow = Ngrid, ncol = Ngrid )
  
  return(new_grid)
}

# newgrid1<- redistributegrid(hqvec = hq1, Nanimals = 100, Ngrid = 10)

##############################################
# no longer complete guess, uses binomial to figure out probability of one success based on 
# prob1success = probability of finding and killing one animal in a square
# can be adjusted for each species

probabilityfxn<- function(n,prob1success){
  prob<- matrix(NA, nrow=nrow(n), ncol=ncol(n))
  for(i in 1:nrow(n)){
    for(j in 1:ncol(n)){
      if(n[i,j] == 0){
        prob[i,j]<- 0
      }
      else{
        # prob[i,j]<- 1/ (1 + (1/.03- 1)*exp(-.15*n[i,j]))
        # prob[i,j]<- 1/ (1 + (1/.15- 1)*exp(-.15*n[i,j]))
        
        prob[i,j]<- 1 - ( 1 - prob1success)^(n[i,j])
        
      }
    }
  }
  return(prob)
}

#################################################

# Calculate straight distance between two points

distancefxn<- function(start, target){
  x1<- start[1]
  y1<- start[2]
  x2<- target[1]
  y2<- target[2]
  distance<- sqrt((x2 - x1)^2 + (y2-y1)^2)
  return(distance)
}

#################################################

# population dynamics

populationdynamics<- function(original.fxn, current.fxn, Ngrid.fxn, r.fxn, hqvec.fxn){
  
  updated<- matrix(NA, nrow = Ngrid.fxn, ncol = Ngrid.fxn) #new distribution
  
  currenttotal<- sum(current.fxn) #current population size
  originaltotal<- sum(original.fxn) #should equal nspecies1 -- carrying capacity
  
  ##logistic growth
  lambda<- currenttotal + r.fxn* currenttotal * (1 - currenttotal/originaltotal)
  
  if(originaltotal == 0){
    print("incorrect")
    lambda<- 0
  }
  
  ## stochasticity -- poisson process
  newtotal<-  rpois(1, lambda)
  
  ## This combines movement and growth:
  updated<- redistributegrid(hqvec = hqvec.fxn, Nanimals = newtotal, Ngrid = Ngrid.fxn)
  
  
  return(updated)
  
}



################################################
# Advance one time step
# Animals reproduce (logistic), then poachers take (no preference for age/sex/etc.)
#this should take in distance grid
#should maybe make this multiple functions?


nexttimestep2species<- function(Ngrid, originalgridsp1, currentgridsp1, rsp1, 
                                originalgridsp2, currentgridsp2, rsp2,
                                distancegrid, 
                                numberpoachers, 
                                takengridsp1, takengridsp2,
                                variablec, fixedc, # revenuesp1, revenuesp2, 
                                aasp1, aasp2,bbsp1, bbsp2, zsp1, zsp2,
                                totalrev, totalcost, numbertrips,
                                prob1successsp1, prob1successsp2, sigmawsp1, sigmawsp2,
                                sigmav, selectivity = 1, Probleave1,
                                Probleave2, ammocost, carrybackcost, step, hqvecsp1, hqvecsp2){
  
  ## population dynamics and movement, new =================
  # Do not do population dynamics if step = 1, that would be changing the starting grid which we do not want.
  if(step == 1){
    updatedgridsp1<- currentgridsp1
    updatedgridsp2<- currentgridsp2
  }
  
  if(step != 1){
    updatedgridsp1<- populationdynamics(original.fxn = originalgridsp1, current.fxn =  currentgridsp1, 
                                        Ngrid.fxn =  Ngrid, r.fxn =  rsp1, hqvec.fxn = hqvecsp1)
    
    updatedgridsp2<- populationdynamics(original.fxn =  originalgridsp2, current.fxn = currentgridsp2, 
                                        Ngrid.fxn =  Ngrid, r.fxn =  rsp2, hqvec.fxn = hqvecsp2)
  }
  

  
  ## Cost grid -- not species dependent
  
  costgrid<- variablec*distancegrid + fixedc #variable cost per unit of distance traveled
  #simplified fixed cost to be fixed cost/rhino harvested
  
  # add ammo cost and carrying dead animal/animal part cost 
  costgrid<- costgrid + ammocost #+ distancegrid * carrybackcost
  
  ############# should i have ammo cost as a probability of harvesting something?
  
  
  
  profitperyear<- 0
  
  catchperyearsp1<- 0
  
  catchperyearsp2<- 0
  
  totalcatchperyear<- 0
  
  sp1rev<- 0
  
  sp2rev<- 0
  
  expectedprofitperyear<- 0
  
  ## Revenue grid -- combines both species? -- this may need to be changed --> at the beginning of the time step.
  revenuesp1<- aasp1 + bbsp1/(.000000001 ^ zsp1) #default (originally had at zero, but made CI's funky)
  revenuesp2<- aasp2 + bbsp2/(.000000001 ^ zsp2) #default
  
  if(sum(updatedgridsp1 != 0)){
    revenuesp1<- aasp1 + bbsp1/(sum(updatedgridsp1)^zsp1) #anthropogenic allee equation, if they are not extinct
  }
  if(sum(updatedgridsp2 != 0)){
    revenuesp2<- aasp2 + bbsp2/(sum(updatedgridsp2)^zsp2) #anthropogenic allee equation, if they are not extinct
  }

  # 
  # print("revenue by year")
  # print(c(revenuesp1, revenuesp2))
  
  ## POACHING HAPPENS 
  
  for(num in 1:numberpoachers){
    
    c<- 2  #concentration coefficient-- should make function input
    
    ## create probability grid-- probability of successful catch for Species 1
    
    probabilitygridsp1<- probabilityfxn( n = updatedgridsp1, prob1success = prob1successsp1)
    
    ## create probability grid-- probability of successful catch for Species 1
    
    probabilitygridsp2<- probabilityfxn(n = updatedgridsp2, prob1success = prob1successsp2)
    
    
    revenuegrid<- revenuesp1 * probabilitygridsp1 + revenuesp2 * probabilitygridsp2 * (1 - probabilitygridsp1) #for species 2, it is the probability you don't catch species 1 AND you catch species two? yeah?
    
    profitgrid<- revenuegrid - costgrid   
    
    ## ADD OBSERVATION ERROR -- currently have it where the error is different for every grid and for every poacher -- unsure if this should be "less" different? Can you correlate observation error? Is that even neccessary?
    ##get rid of matrix
    observationerror<- matrix(data = rnorm(n = (Ngrid * Ngrid), mean = 0, sd = sigmav), nrow = Ngrid, ncol = Ngrid)
    
    profitgrid<- profitgrid + observationerror
    
    
    
    ## fleet dynamics
    
    if(max(profitgrid >=0)){
      fleetdynamics<- exp(-c * (1 - profitgrid / max(profitgrid)))
    }
    else{
      fleetdynamics<- exp(-c * (1 - profitgrid / .000000001)) 
    }
    
    
    ## Probability for each square
    
    if(sum(fleetdynamics) != 0){
      fleetdynamicsprobability<- fleetdynamics/sum(fleetdynamics)
    }
    else{
      fleetdynamicsprobability<- matrix(0, nrow = Ngrid, ncol = Ngrid)
    }
    
    ## Pick a square to go to
    
    randnumb<- runif(n = 1)
    temp<- 0
    xtarget<- -1
    ytarget<- -1
    cumulativefleetdyprob<- matrix(0, nrow=Ngrid, ncol = Ngrid)
    marker<- F
    for(i in 1:Ngrid){
      for(j in 1:Ngrid){
        temp<- temp + fleetdynamicsprobability[i,j]
        cumulativefleetdyprob[i,j]<- temp
        if(is.na(temp)==TRUE){
          print("WARNING, Temp = NA")
          print(temp)
          print(fleetdynamics)
          print(fleetdynamicsprobability)
          print(sum(fleetdynamicsprobability))
        }
        else if(randnumb <= temp & marker == F){
          xtarget<- i
          ytarget<- j
          marker<- T
        }
      }
    } 
    
    
    ## only harvesting ONE animal!!!!!!!!!!!!!!!
    
    if(xtarget != -1){
      if(marker != F & profitgrid[xtarget, ytarget] > 0){ 
        
        #keep track of number of trips - the poacher goes
        numbertrips<- numbertrips + 1
        
        # SPECIES 1- catch 1 or 0
        tempcatchsp1<- rbinom(n = 1, size = 1, prob = probabilitygridsp1[xtarget, ytarget])
        
        # SPECIES 2- catch 1 or 0
        tempcatchsp2<- rbinom(n = 1, size = 1, prob = probabilitygridsp2[xtarget, ytarget])
        
        # did they catch anything? 
        
        # if the revenue is less than the ammunition and cost to carry back, don't harvest
        
        addedcost<- ammocost #+ carrybackcost * distancegrid[xtarget, ytarget]
        
        if(revenuesp2 <= addedcost){
          tempcatchsp2<- 0
        }
        
        if(revenuesp1 <= addedcost){
          tempcatchsp1<- 0
        }
        
        
        # what happens if they see both? Catch most expensive and not the least expensive
        if(tempcatchsp1 == 1 & tempcatchsp2 == 1){
          
          if(selectivity == 1 ){
            # print("selectivity = always take most profitable")
            ## automatically take the most profitable one (even if it is by 50 cents)
            if(revenuesp1 > revenuesp2){
              tempcatchsp2<- 0
            } else if(revenuesp2 > revenuesp1){
              tempcatchsp1<- 0
            } else{
              multinomcatch<- rmultinom(n = 1, size = 1, prob = c(utilsp1, utilsp2))
              tempcatchsp1<- multinomcatch[1]
              tempcatchsp2<- multinomcatch
            }
          } else {
            # equal utility per dollar 
            # print("selectivity = utility and money have 1:1 ratio")
            utilsp1<- revenuesp1/ (revenuesp1 + revenuesp2)
            utilsp2<- revenuesp2/ (revenuesp1 + revenuesp2)
            
            multinomcatch<- rmultinom(n = 1, size = 1, prob = c(utilsp1, utilsp2))
            tempcatchsp1<- multinomcatch[1]
            tempcatchsp2 <- multinomcatch[2]
          }
          
        }
        
        
        ## remove catch from Species 1 grid
        updatedgridsp1[xtarget, ytarget]<- updatedgridsp1[xtarget, ytarget] - tempcatchsp1
        
        ## remove catch from Species 2 grid
        updatedgridsp2[xtarget, ytarget]<- updatedgridsp2[xtarget, ytarget] - tempcatchsp2
        
        #keep track of how many Species 1 caught
        takengridsp1[xtarget, ytarget]<- takengridsp1[xtarget, ytarget] + tempcatchsp1
        
        #keep track of how many Species 2 caught
        takengridsp2[xtarget, ytarget]<- takengridsp2[xtarget, ytarget] + tempcatchsp2
        
        #catch per year of species 1
        catchperyearsp1<- catchperyearsp1 + tempcatchsp1
        
        #catch per year of species 2
        catchperyearsp2<- catchperyearsp2 + tempcatchsp2
        
        #total catch per year
        
        totalcatchperyear<- totalcatchperyear + tempcatchsp1 + tempcatchsp2
        
        #keep track of total revenue, total cost, yearly revenue
        totalrev<- totalrev + revenuesp1 * tempcatchsp1 + revenuesp2 * tempcatchsp2
        
        sp1rev<- sp1rev + revenuesp1 * tempcatchsp1
        
        sp2rev<- sp2rev + revenuesp2 * tempcatchsp2
        
        totalcost<- totalcost + costgrid[xtarget, ytarget]
        
        profitperyear<- profitperyear + revenuesp1 * tempcatchsp1 + revenuesp2 * tempcatchsp2 - costgrid[xtarget, ytarget]
        
        expectedprofitperyear<- expectedprofitperyear + profitgrid[xtarget, ytarget] #THIS IS NOT ACCURATE SINCE THEY CAN ONLY CATCH ONE!!!
        
      }
      
    }
    
  }

  
  new_list <- list(takengridsp1, takengridsp2, updatedgridsp1, updatedgridsp2, totalrev, totalcost, profitperyear, 
                   catchperyearsp1, catchperyearsp2, totalcatchperyear, numbertrips, expectedprofitperyear, 
                   revenuesp1, revenuesp2)
  return(new_list)
}



################################################################
#advances multiple time steps



multipletimesteps2species<- function(Omega_gridsp1.fxn, Omega_gridsp2.fxn, Nanimalssp1.fxn,
                                     Nanimalssp2.fxn, Ngrid.fxn, 
                                     numberpoachers.fxn, nstep.fxn,
                                     rsp1.fxn, rsp2.fxn, variablec.fxn, fixedc.fxn, # revenuesp1.fxn, revenuesp2.fxn,
                                     aasp1.fxn, aasp2.fxn, bbsp1.fxn, bbsp2.fxn, zsp1.fxn, zsp2.fxn,
                                     prob1successsp1.fxn, prob1successsp2.fxn, sigmawsp1.fxn, sigmawsp2.fxn,
                                     sigmav.fxn, selectivity.fxn = 1, Probleave1.fxn,
                                     Probleave2.fxn, ammocost.fxn, carrybackcost.fxn){
  
  marker1<- F
  marker2<- F
  
  extinctionstepsp1<- 0
  extinctionstepsp2<- 0
  
  ####################### arrays to hold distribution grids
  distarraysp1<- array(data = NA, dim = c(Ngrid.fxn, Ngrid.fxn, (nstep.fxn + 1)))
  distarraysp2<- array(data = NA, dim = c(Ngrid.fxn, Ngrid.fxn, (nstep.fxn + 1)))
  #######################
  
  ####################### vector to hold population size by year
  yearlypopsize1<- rep(data = NA, nstep.fxn + 1)
  yearlypopsize2<- rep(data = NA, nstep.fxn + 1)
  #######################
  
  ####################### vector to hold revenue by year
  yearlyrevenue1<- rep(data = NA, nstep.fxn + 1)
  yearlyrevenue2<- rep(data = NA, nstep.fxn + 1)
  #######################
  # print("start grid sp1")
  
  ## Starting grid for species 1
  
  #set.seed(15)
  
  originalgridsp1<- createstartgrid(Jim_grid = Omega_gridsp1.fxn, Nanimals = Nanimalssp1.fxn, Ngrid = Ngrid.fxn) #carrying capacity
  # title(main = "Original population Species 1", col.main = "green")
  # print(originalgridsp1)
  hq1<- createhqvec(Omega_gridsp1.fxn)
  
  currentgridsp1<- originalgridsp1  #matrix that will be changed, assume starting at carrying capacity
  
  distarraysp1[,,1]<- currentgridsp1
  
  yearlypopsize1[1]<- sum(currentgridsp1)
  ## Starting grid for species 2
  
  # print("start grid sp2")
  
  # set.seed(15) 
  
  originalgridsp2<- createstartgrid(Jim_grid = Omega_gridsp2.fxn, Nanimals = Nanimalssp2.fxn, Ngrid = Ngrid.fxn) #carrying capacity
  # title(main = "Original population Species 2", col.main = "green")
  # print(originalgridsp2)
  hq2<- createhqvec(Omega_gridsp2.fxn)
  
  currentgridsp2<- originalgridsp2  #matrix that will be changed, assume starting at carrying capacity
  
  distarraysp2[,,1]<- currentgridsp2
  
  yearlypopsize2[1]<- sum(currentgridsp2)
  
  ### distance grid calculation (outside of loop to save time)
  
  distancegrid<- matrix(NA, ncol = Ngrid.fxn, nrow= Ngrid.fxn)
  
  for(i in 1:Ngrid.fxn){
    for(j in 1:Ngrid.fxn){
      distancegrid[i,j]<- distancefxn(start = c(0,0), target = c(i-.5, j-.5))  #note that they are starting in specified corner
    }
  }
  ### 
  #calculate observation error sigma -- based on the total revenue available (may want to make it more specific)
  originalrevsp1<- aasp1.fxn + bbsp1.fxn/(sum(originalgridsp1)^zsp1.fxn)
  originalrevsp2<- aasp2.fxn + bbsp2.fxn/(sum(originalgridsp2)^zsp2.fxn)
  
  yearlyrevenue1[1]<- originalrevsp1
  yearlyrevenue2[1]<- originalrevsp2
  
  sigmav.fxn<- sigmav.fxn * mean(originalgridsp1 * originalrevsp1 + originalgridsp2 * originalrevsp2)
  # 
  #   print("mean of revenue grid")
  #   print(mean(originalgridsp1 * revenuesp1.fxn + originalgridsp2 * revenuesp2.fxn))
  
  # print("observation error st.dev")
  # print(sigmav.fxn)
  
  
  
  
  ###
  
  takengridsp1<- matrix(0, nrow = Ngrid.fxn, ncol = Ngrid.fxn) #empty starting grid to fill with captured animals
  takengridsp2<- matrix(0, nrow = Ngrid.fxn, ncol = Ngrid.fxn) 
  
  
  totalrev<- 0 #starting revenue
  
  totalcost<- 0 #starting cost
  
  numbertrips<- 0 #starting number of trips
  
  populationsizesp1<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  populationsizesp2<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  
  takensp1<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  takensp2<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  
  totaltaken<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  
  yearlyprofit<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  
  yearlytotalcatch<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  yearlycatchsp1<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  yearlycatchsp2<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  
  expectedyearlyprofit<- matrix(c(1:nstep.fxn, rep(0, nstep.fxn)), nrow = nstep.fxn, ncol = 2, byrow = FALSE)
  
  for (step in 1:nstep.fxn){
    populationsizesp1[step,2]<- sum(currentgridsp1)
    populationsizesp2[step,2]<- sum(currentgridsp2)
    
    totaltaken[step,2]<- sum(takengridsp1) + sum(takengridsp2)
    
    if(sum(currentgridsp1) != 0 | sum(currentgridsp2) != 0){
      temp<- nexttimestep2species(Ngrid = Ngrid.fxn, originalgridsp1 = originalgridsp1, currentgridsp1 = currentgridsp1,
                                  rsp1 = rsp1.fxn, originalgridsp2 = originalgridsp2, currentgridsp2 = currentgridsp2, 
                                  rsp2 = rsp2.fxn, 
                                  distancegrid = distancegrid,
                                  numberpoachers = numberpoachers.fxn, takengridsp1 = takengridsp1, 
                                  takengridsp2 = takengridsp2, 
                                  variablec = variablec.fxn, fixedc = fixedc.fxn,
                                  # revenuesp1 = revenuesp1.fxn, revenuesp2 = revenuesp2.fxn,
                                  aasp1 = aasp1.fxn, aasp2 = aasp2.fxn ,bbsp1 = bbsp1.fxn, 
                                  bbsp2 = bbsp2.fxn, zsp1 = zsp1.fxn, zsp2 = zsp2.fxn,
                                  totalrev = totalrev, totalcost = totalcost,
                                  numbertrips = numbertrips,
                                  prob1successsp1 = prob1successsp1.fxn, 
                                  prob1successsp2 = prob1successsp2.fxn,
                                  sigmawsp1 = sigmawsp1.fxn,
                                  sigmawsp2 = sigmawsp2.fxn,
                                  sigmav = sigmav.fxn,
                                  selectivity = selectivity.fxn,
                                  Probleave1 = Probleave1.fxn,
                                  Probleave2 = Probleave2.fxn,
                                  ammocost = ammocost.fxn, 
                                  carrybackcost = carrybackcost.fxn,
                                  step = step, hqvecsp1 = hq1, hqvecsp2= hq2)
      
      currentgridsp1<- temp[[3]] #updates current grid species 1
      distarraysp1[,,(step + 1)]<- currentgridsp1
      yearlypopsize1[step + 1]<- sum(currentgridsp1)
      currentgridsp2<- temp[[4]]
      distarraysp2[,,(step+1)]<- currentgridsp2
      yearlypopsize2[step + 1]<- sum(currentgridsp2)
      takengridsp1<- temp[[1]] #updates taken grid
      takengridsp2<- temp[[2]]
      totalrev<- temp[[5]] #updates total revenue
      totalcost<- temp[[6]] #updates total cost
      numbertrips<- temp[[11]] #updates number of trips
      yearlyprofit[step, 2]<- temp[[7]] #keeps track of profit in each time step
      yearlytotalcatch[step, 2]<- temp[[10]] #keeps track of catch in each time step
      yearlycatchsp1[step,2]<- temp[[8]]
      yearlycatchsp2[step,2]<- temp[[9]]
      expectedyearlyprofit[step, 2]<- temp[[12]]
      yearlyrevenue1[step + 1]<- temp[[13]]
      yearlyrevenue2[step + 1]<- temp[[14]]
      
      if(sum(currentgridsp1) == 0 & marker1 == F){
        extinctionstepsp1<- step
        marker1<- T
      }
      
      if(sum(currentgridsp2) == 0 & marker2 == F){
        extinctionstepsp2<- step
        marker2<- T
      }
      
      if(sum(currentgridsp1) == 0 & sum(currentgridsp2) == 0){
        break
      }
    }
    
  }
  
  # print("Total Number Species 1 Taken")
  # print(takengridsp1)
  # print(sum(takengridsp1, na.rm = TRUE)) #total number Species 1 taken
  # image(takengridsp1, col=Col(n=10), xlab="X coordinate - rows", ylab="Y coordinate- collumns", 
  #       zlim=c(1, max(1,max(takengridsp1))) )
  # title(main = "Species 1 number taken", col.main = "green")
  # #note: not on same color scale as other images
  # 
  # print("Total Number Species 2 Taken")
  # print(takengridsp2)
  # print(sum(takengridsp2, na.rm = TRUE)) #total number Species 1 taken
  # image(takengridsp2, col=Col(n=10), xlab="X coordinate - rows", ylab="Y coordinate- collumns", 
  #       zlim=c(1, max(1,max(takengridsp2))) )
  # title(main = "Species 2 number taken", col.main = "green")
  # #note: not on same color scale as other images
  # 
  # 
  # print("Animal population Species 1")
  # print(currentgridsp1)
  # print(sum(currentgridsp1))
  # image(currentgridsp1, col=Col(n=10), xlab="X coordinate - rows", ylab="Y coordinate- collumns",
  #       zlim=c(1, max(1,max(currentgridsp1))) )
  # title(main = "Current population Species 1", col.main = "green")
  # #note: not on same color scale as other images
  # 
  # print("Animal population Species 2")
  # print(currentgridsp2)
  # print(sum(currentgridsp2))
  # image(currentgridsp2, col=Col(n=10), xlab="X coordinate - rows", ylab="Y coordinate- collumns",
  #       zlim=c(1, max(1,max(currentgridsp2))) )
  # title(main = "Current population Species 2", col.main = "green")
  # #note: not on same color scale as other images
  # 
  # 
  # 
  # print("extinction time step Species 1")
  # print(extinctionstepsp1)
  # 
  # print("extinction time step Species 2")
  # print(extinctionstepsp2)
  # 
  # print("total revenue")
  # print(totalrev)
  # 
  # print("total cost")
  # print(totalcost)
  # 
  # print("Number of trips")
  # print(numbertrips)
  # 
  # 
  # plot(x = yearlyprofit[,1], y = yearlyprofit[,2], xlab = "time step", ylab = "profit per year",
  #      type = "l", main = "profit per time step")
  # lines(x = expectedyearlyprofit[,1], y = expectedyearlyprofit[,2], col= "red", lty = 3)
  # 
  # plot(x = populationsizesp1[,1], y = populationsizesp1[,2], xlab = "time step", ylab = "population size", type = "l",
  #      ylim = c(0, max(Nanimalssp2.fxn, Nanimalssp1.fxn)), main = "Population size over time", col = "orange")
  # lines(x = populationsizesp2[,1], y = populationsizesp2[,2], col = "purple")
  # 
  # plot(x = totaltaken[,1], y = totaltaken[,2], xlab = "time step", ylab = "number taken", type = "l",
  #      main = "Total number taken over time")
  # 
  # 
  # plot(x = yearlytotalcatch[,1], y = yearlytotalcatch[,2], xlab = "time step", ylab = "total number taken per year", type = "l",
  #      main = "Total number taken each year")
  # lines(x = yearlycatchsp1[,1], y = yearlycatchsp1[,2], col = "orange")
  # lines(x = yearlycatchsp2[,1], y = yearlycatchsp2[,2], col = "purple")
  # 
  
  invisible(list(originalgridsp1, currentgridsp1, originalgridsp2, currentgridsp2, distarraysp1,
                 distarraysp2, yearlypopsize1, yearlypopsize2, yearlyrevenue1, yearlyrevenue2, 
                 extinctionstepsp1, extinctionstepsp2))
}


###############################
# # EXAMPLE CODE TO RUN FUNCTION -- plotting is turned off
# 
# examplecall <- multipletimesteps2species(Omega_gridsp1.fxn = Omega_gridSpecies1, Omega_gridsp2.fxn = Omega_gridSpecies1,
#                                          Nanimalssp1.fxn = 1000, Nanimalssp2.fxn = 2000, Ngrid.fxn = 10,
#                                          numberpoachers.fxn = 50, nstep.fxn = 25,
#                                          rsp1.fxn = .09, rsp2.fxn = .09,
#                                          variablec.fxn = 100, fixedc.fxn = 100,
#                                          # revenuesp1.fxn = 0,revenuesp2.fxn = 0,
#                                          aasp1.fxn = 2000, aasp2.fxn = 1000, bbsp1.fxn = 1000, 
#                                          bbsp2.fxn = 5000, zsp1.fxn = .25, zsp2.fxn = .25,
#                                          prob1successsp1.fxn = .09, prob1successsp2.fxn = .09,
#                                          sigmawsp1.fxn = 0, sigmawsp2.fxn = 0, sigmav.fxn = 0,
#                                          selectivity.fxn = 2, Probleave1.fxn = 0.05, Probleave2.fxn = 0.05,
#                                          ammocost.fxn = 1, carrybackcost.fxn = 50)
# examplecall[[7]]
